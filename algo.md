## 1

```js
(m == n) ? 'OK' : 'ERROR'
```

## 2

```php
function plus_sort($s){
	$array = explode('+', $s);
	sort($array);
	return implode('+', $array);
}
```

## 3

Есть вариант с перебором, но возможно ожидается что-то из комбинаторики для оптимизации производительности, надо подумать

## 4

```php
function dec47($n){
	if(!preg_match('/^[47]+$/', $n))
		return; // дополнительная проверка
	$bin = str_replace([4,7], [0,1], $n);
	$dec = bindec($bin)+1;
    return $dec;
}
```

## 5

Брут curl'ом на http response code + timeout, первый положительный результат записать, затем exec('google-chrome ' . $first_url) 

Лучше заверну в приложение, если надо будет

## 6

Т.к. это не паскаль, то параметр с количеством брусков нам не нужен, делаем **explode(' ', $строка)** и передаём в функцию:

```php
function bcnt($first, $second){
    $n = 0;
    foreach($first as $a){
        $n += count(array_filter($second, function($b) use ($a){
        
            // не in_array, потому, что во второй кучке может лежать 2 одинаковых по длине бруска
            
            return ($b == $a + 1) || ($b == $a - 1);
            });
    }
    return $n;
}
```

## 7

По примерам входных данных:

Если 6, то после того, как я перебрал возможные комбинации, то получилось 7 или 8, а если рассмотреть вариант в обратном порядке, то всё умножается на 2. Надо подумать.

## 8 

Пока не понял)


